1.4 Analog & PWM
=========================
In previous study, we have known that one button has two states: pressed and 
released, and LED has lighton/off state, then how to enter a middle state? How 
to output an intermediate state to let LED "semi bright"? That's what we're going 
to learn. First, let’s learn how to control the brightness of a LED.

Meteor Flowing Light
------------------------------------
After learning about PWM, we can use it to control LED bar graph and realize a 
cooler flowing light. The component list, circuit, and hardware are exactly cons
istent with the project Flowing Light.

Component List
^^^^^^^^^^^^^^^
- Raspberry Pi Pico W x1
- MicroUSB cable x1
- 830 Tie-Points Breadboard x1
- Resistor 220Ω x10
- Jumper Wire Several
- LED Bar Graph x1

This project has the same circuit as Project 1.3, but the output signal is different. 
In Project 1.3, high and low voltage levels (0 & 1) are directly output to turn the 
LEDs on or off. In this project, PWM signals are output to control the brightness of 
the LED Bar Graph, achieving a flowing effect.

Connect
^^^^^^^
.. image:: img/3.connect/1.4.png

Code
^^^^^^^
.. note::

    * Open the ``1.4_analog_pwm.ino`` file under the path of ``Ultimate-Starter-Kit-for-Pico-W\Arduino\1.Project`` or copy this code into Thonny, then click "Run Current Script" or simply press F5 to run it.

    * Or copy this code into Arduino IDE.

    * Don’t forget to select the board(Raspberry Pi Pico) and the correct port before clicking the Upload button.
  
Click “Run current script”, the LED Bar Graph will continuously flow from left to right.

The following is the program code:

.. code-block:: c++

    const int pinNums[] = {6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
    const int PIN_COUNT = 10; 

    const int STEPS = 32;
    const int MAX_DUTY = 255; 
    int breathPattern[STEPS];

    void setup() {
    for (int i = 0; i < PIN_COUNT; i++) {
        pinMode(pinNums[i], OUTPUT);
    }
    
    for (int i = 0; i < STEPS; i++) {
        float ratio = 1.0 - abs((i - STEPS/2.0)/(STEPS/2.0));
        breathPattern[i] = int(MAX_DUTY * ratio);
    }
    }

    void loop() {
    for (int step = 0; step < STEPS; step++) {
        for (int i = 0; i < PIN_COUNT; i++) {
        int phase = (step - i * 2) % STEPS;
        if (phase < 0) {
            phase += STEPS;
        }
        analogWrite(pinNums[i], breathPattern[phase]);
        }
        delay(50);
    }
    }

Phenomenon
^^^^^^^^^^^
.. video:: img/5.phenomenon/1.4.mp4
    :width: 100%
